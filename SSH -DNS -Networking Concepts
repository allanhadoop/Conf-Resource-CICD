# source - http://blog.trackets.com/2014/05/17/ssh-tunnel-local-and-remote-port-forwarding-explained-with-examples.html
# Two types of SSH tunneing -  local and remote port forwarding
# Real life scenario - Imagine you’re on a private network which doesn’t allow connections to a specific server. Let’s say you’re at 
work and imgur.com is being blocked. To get around this we can create a tunnel through a server which isn’t on our network and thus 
can access Imgur.

$ ssh -L 9000:imgur.com:80 user@example.com

# The key here is -L which says we’re doing local port forwarding. Then it says we’re forwarding our local port 9000 to imgur.com:80, 
which is the default port for HTTP. Now open your browser and go to http://localhost:9000. SSH tunnels is that they are encrypted. 
Nobody is going to see what sites you’re visiting, they’ll only see an SSH connection to your server. SO basically all data packets received from 
imgur.com:80 is now diverted to localhost on port 9000.


#----Connecting to a database behind a firewall
Scenario - you need to access a port on your server which can only be accessed from localhost and not remotely.when you need to connect 
to a database console, which only allows local connection for security reasons. Let’s say you’re running PostgreSQL on your server, which 
by default listens on the port 5432.

$ ssh -L 9000:localhost:5432 user@example.com

# The part that changed here is the localhost:5432, which says to forward connections from your local port 9000 to localhost:5432 on your 
server. Now we can simply connect to our database.

$ psql -h localhost -p 9000

In the first example the 9000:imgur.com:80 is actually saying forward my local port 9000 to imgur.com at port 80. You can imagine SSH on 
your server actually making a connection (a tunnel) between those two ports, one on your local machine, and one on the target destination.
If we however say something like 9000:localhost:5432, it means localhost from the server’s perspective, not localhost on your machine. 
This means forward my local port 9000 to port 5432 on the server, because when you’re on the server, localhost means the server itself.

#--------------Remote port forwarding
Scenario - Say that you’re developing a Rails application on your local machine, and you’d like to show it to a friend. Unfortunately 
your ISP didn’t provide you with a public IP address, so it’s not possible to connect to your machine directly via the internet.
Sometimes this can be solved by configuring NAT (Network Address Translation) on your router, but this doesn’t always work, and it 
requires you to change the configuration on your router, which isn’t always desirable. This solution also doesn’t work when you don’t 
have admin access on your network.

To fix this problem you need to have another computer, which is publicly accessible and have SSH access to it. It can be any server on 
the internet, as long as you can connect to it. We’ll tell SSH to make a tunnel that opens up a new port on the server, and connects it 
to a local port on your machine.

$ ssh -R 9000:localhost:3000 user@example.com

The syntax here is very similar to local port forwarding, with a single change of -L for -R. But as with local port forwarding, the 
syntax remains the same.First you need to specify the port on which th remote server will listen, which in this case is 9000, and next 
follows localhost for your local machine, and the local port, which in this case is 3000.
SSH doesn’t by default allow remote hosts to forwarded ports. To enable this open /etc/ssh/sshd_config and add the following line 
somewhere in that config file.

sudo nano /etc/ssh/sshd_config
GatewayPorts yes
$ sudo service ssh restart

This means that if you connect to the server on port 9000 from your local machine, you’ll actually make a request to your machine 
through the SSH tunnel.

## Tip = every time we create a tunnel you also SSH into the server and get a shell. This isn’t usually necessary, as you’re just trying 
to create a tunnel. To avoid this we can run SSH with the -nNT flags, such as the following, which will cause SSH to not allocate a tty 
and only do the port forwarding

$ ssh -nNT -L 9000:imgur.com:80 user@example.com

-----------------------------------------------------------------DNS ------------------------------------------

# Use wireshark to analyze your internet data packets . In wireshark , we will see various packets under various protocols like UDP, TCP , 
ICMP ( Internet control messaging protocol) . 

Standard query will tell which domain we are trying to open or query to DNS and Standard reponse will show its IP address.
DNS tries to check Host file first to see if it can answer standard query to get IP address of domain that we are typing, if not found
then it searches DNS cache and if not found there too then it checks on DNS server

Firs update Host files and then flush DNS cache. 
Host files at Windows = /etc/hosts
Host files at Mac = /etc/hosts and to flush DNS cache - dscacheutil - flushcache; sudo killall - HUP mDNSResponder 
Host files at Linus = /etc/hostss 

To Check what is already there in DNS cache, 
Windows machine - ipconfig /displaydns
On Mac - 
>> sudo killall -INFO mDNSResponder
A SIGINFO signal will dump a snapshot summary of the internal state to /var/log/system.log:

Additionally , we can specify loopback ip 127.0.0.1 with CantGetThereFromHere.com sites so that no one can access those sites since it will 
go to loopback circle and will be blocked.
127.0.0.1     CantGetThereFromHere.com 

So Your machine ---> talkes to locally installed DNS server for ip address for given domain name --> if not found then local DNS server
will connect to DNS root server and it goes in chain till it find IP. and once found it make final check at that particular domain 
web server so that it can provide the IP that you are looking for your domain. 
Check architecural diagram. Local DNS server has root hints , 
that is how it know which is root DNS server to contact to get IP address. Root hints stores those root DNS server entry in your local DNS 
server. On Windows it can be found at LocalDisk -->Windows --> System32 --> dns --> Cacahe.dns file. 

Authoritative - 
If you get IP address from your local DNS server zone file then it is authoritattive.

Non-Authoritative - This means if local DNS server has to talk to root DNS server and other .com servers to get the IP address

Root Hint files has different structure as shown in the architecture diagram . 
It has root server name(which always ends with .) , then number (which is time to live (TTL) which says how long data valid), 
NS (name server name), A (which is IPv4 address) and AAAA(which is IPv6 address). 

-----Iterative and Recursive queries and recursion ---
If root , .com and other DNS servers are involved to get the IP of the domain that you are looking for then it is called iterative and this
process is called recursion.
if your local DNS server can get you IP for your domain then it is called recursive queries.

----DNS Hierarchy - See diagram under architecture folder
--> .Root DNS server ---> .com DNS server ----> .other domain server 
Whether it is recursive or iterative query, how it happened in the backend can be visible in wireshark under DNS section.
There is recursive flag.

------DNS Zones ( Forward and Reverse ) --------------
1. Forward lookup zones - Find IP address of given host name..This is normal and most use scenario 
2. Reverse lookup zones - Get host name for given IP address. Example nslookup 10.20.23.2 or traceroute or SMTP will try to find domain 
or host name


----Creating host , resource Records ---------------------------
A - IPv4 record
AAAA - IPv6 record
CNAME - Cananocal name /nick name 
SRV - Service Locator record - e.g. different services that are running on microsoft server . there are other SRVs 
MX - Email exchange records that denote mail server
NAPTR - Name authority pointer
NS - name server record , meaning DNS server is running here.
SOA - Start of authority or DNS server providing authoratative information 

----------------------------Zone types ----------------------------------
1. Primary Zones
  . Authoratative Zone Information 
  . Contains read/write copy of zone data
  . Accepts dynamic updates from clients(ddns)
2. Secondary Zone Server
   - basically these are copy of primary DNS zone server just to sever local clients . it is a copy of primary DNS zones.
   Also it is read only. initially we do AXFR (meaning all data is transfered) and after that IXFR (incremental data change is transfered)
   So data from primary DNS server can be transfered using UDP (all data in one packet) or TCP (if data is large then it is divided into
   small packets)
3. Stub Zones - Its like one DNS server referring to anthoer DNS server if client wish to connect to that DNS server. 
   - see architectural diagram
4. Cache Only
5. Zone Transfers

























